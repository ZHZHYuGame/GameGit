二丶Buff系统

        buff系统是战斗系统中最核心又最复杂的系统,用来增加游戏战斗的深度还有可玩性,支持更多的效果和功能

        正文

buff的定义一般分为三个层次

BuffBase:所有Buff的基类,包含各类成员函数和基本接口()

Modifier:继承于BuffBase,是一个关于buff的修改器,可以用来修改当前目标的属性状态等等

MotionModifier:继承于Modifier,代表的是此类提供修改玩家运动效果的功能.因为会牵扯到于运动组件的交互,所以抽象出一个新的类

Buff需要哪些常用数据:

 BuffTypeID(Buff类型ID), Caster(Buff施加者),Parent (Buff当前挂载的目标),Ability(Buff是由哪个技能创建) ,BuffLayer(层数),BuffLevel(等级),BuffDuration(时长),BuffTag,BuffImmuneTag(免疫BuffTag)以及Context(Buff创建时的一些相关上下文数据)等等

其中,Caster,Ability以及Context这三个成员是很独特的一点

Caster施加者是可以存在也可以不存在的,是要根据Buff的一个配置项 bNoCaster=true||false来判断是否存在施加者,也就是说这个状态可以同时判断是否多个施加者同时放Buff的时候进行一个叠加问题(如果多个施加者的话,则这个状态为true)就跟进入游戏是一个暴雪天气或者炼狱天气,玩家每秒掉多少血同时这个状态也是为True,这个状态就可以避免根据传入施加者来判断是否有施加者

Ability代表Buff是由哪个技能创建,他有肯呢个为空,也有可能不为空,根据是否传Ability参数而定,通过Ability这个成员类型,我们就将Buff与技能联系起来了,我们能在Buff中取得技能的各种数据,通过获取技能的数据,然后由Buff来实现各种各样的技能效果

BuffTag,BuffImmuneTag由策划配置,用来标注这个Buff属于哪些种类以及免疫哪种类型,比如:

Matal=1(金系),Wood=2(木系),Water=3(水系),Fire=4(火系),Earth=5(土系)

如果配置BuffTag为Matal或Water时,配置BuffImmuneTag为Fire或Earth则代表这个Buff可以免疫所有的火系和土系,通过这些可以根据策划需求组合出各种各样的免疫效果

Context代表Buff创建时候的一些上下文数据,他是一个不确定的项,通过外部传入各种自定义的数据,然后在Buff逻辑中使用这些自定义数据

Buff执行的流程
在Buff从创建到销毁的过程中,分为如下几个阶段:

1.Buff创建前检查当前Buff是否可创建,一般不可创建的原因就是前面提到的这个要添加的buff是否会被玩家自身带的Buff给免疫掉了,如果有免疫效果则不会创建此Buff.

2.Buff在实例化之后,生效之前(还没有加入到Buff的容器中)如果说此Buff是一个被动触发的Buff,例如Buff实例化出来的时候会抛出一个事件,等待触发,这个buff的作用是:玩家添加此Buff,这个Buff就是如果3秒钟之内别人对我施加负面Buff的话,那么会立马驱散这个负面Buff的同时在给自己添加一个护盾或者说在给自己添加一些正面的Buff效果,如果说超过这个Buff3秒还没有被负面Buff触发的话,那么就移除触发事件,这样就会意味着Buff还没有被触发就会销毁同时小心Buff的生命周期(例如LOL中轮子妈的W技能)

3.当Buff生效时(加入到Buff容器后),就提供一个抽象接口给策划配置这个Buff的具体效果

4.当Buff添加时存在相同类型且Caster(Buff施加者)相等的时候，Buff执行刷新流程（更新Buff层数，等级，持续时间等数据）。我们提供给策划一个抽象接口OnBuffRefresh，由策划配置具体效果。

5.当Buff销毁前（还未从Buff容器中移除），我们提供给策划一个抽象接口OnBuffRemove，由策划配置具体效果。

6.当Buff销毁后（已从Buff容器中移除），我们提供给策划一个抽象接口OnBuffDestroy，由策划配置具体效果。

Buff由于其有着生命周期可控，低耦合（通过监听事件修改逻辑），高内聚、易于扩展的特性，因此通过使用Buff来管理逻辑的话，不仅方便处理各种复杂的行为，同时还能有效的减少开发者的维护难度。

例如延迟触发伤害这种游戏中常见的需求如何实现:

在简单的游戏中就可以直接给角色挂载一个定时器触发伤害就行

但是逻辑复杂点就会带来很多问题,例如:受到控制效果的时候取消延迟伤害?直接去掉timer定时器吗?但是又过了两天策划又有一个新的需求就是受到控制效果的时候需要延迟伤害立即出发,又怎么办?再比如当角色受到的伤害超过1000点时,这个延迟伤害立即触发,如何实现?

答:可以添加一个持续时间为N秒的Buff,Buff销毁的时候触发伤害;如果需求更改为受到控制时取消伤害,那么我们就在Buff中检查是否包含有Tag类型为Control的Buff,如果有,则设置Buff.TriggerDamage=false,同时自我销毁,然后在BuffDestroy触发的时候检查是否触发伤害,如果TriggerDamage=false则不触发伤害,同理,当需求为Buff监听的伤害超过1000点伤害立即触发时,我们只需要通过Buff监听OnTakeDamage事件,检查受到伤害是否大于1000点,如果是则销毁Buff同时立即触发BuffDestroy并执行伤害效果

上面的例子就能看出整个控制逻辑都是在Buff内部完成的,不需要各种手动开启/取消定时器,只需要Buff本身扩展下逻辑检查即可,具有非常好的扩展性和高内聚性



Buff修改状态(ModifyState)