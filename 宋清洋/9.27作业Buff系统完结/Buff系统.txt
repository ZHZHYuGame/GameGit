Buff修改状态(ModifyState)
Buff可以通过修改状态去影响角色行为逻辑,列举:

        Stun(眩晕状态-----目标不再响应任何操控)

        Rott(缠身,又称为定身状态-----目标不响应移动请求,但是可以执行某些操作,如释放技能)

        Silence(沉默-----目标禁止释放技能)

        Invincible(无敌-----几乎不受到所有的伤害和效果影响)

        Invisible(隐身-----不可被其他人看见)

这几个状态就是Buff里常用到的,抽象的代表,很多游戏效果都是基于 这几种状态+运动+动画的组合,在这里有很多开发者都有一个误区,就是把Buff的状态跟动画耦合到一起,比如:眩晕状态就一定是播放个眩晕动画? 然后击退状态就是击退位移+击退动画? 这样的话到最后的问题就是状态膨胀,而且各种逻辑耦合 Buff频出并且难以维护

我们以Stun(眩晕状态)为例,第一眼就觉得这个就是个DeBuff,是敌人给我方加的控制Buff,实际上并不是,Stun可以用到的地方很多,比如有一个技能是野蛮冲撞,释放的2秒内向前快速移动10米并且将敌人推开,那这个Buff的实现逻辑就是技能在释放的时间内给角色加个Buff,这个Buff有Stun状态同时带位移的突进效果,挂上这个Buff后,技能在释放的2秒时间内就是处于一个跟Stun状态一样的效果,不会响应玩家的按键和释放其他技能请求了,同时往前突进的效果也是由Buff所控制,在处理各种位移打断效果也很方便

其次再比如说有一个技能叫火力屏障:我被一圈火焰围绕着,在这10秒内不会受到任何物理伤害和法术伤害甚至是针对性火属性伤害,但是在这期间无法移动,攻击或者施法,那这个技能实现也很简单,就是一个10秒的Buff同时添加了眩晕和无敌两个状态,如果在这过程中还需要每秒恢复多少血,那么就直接调用接口实现间隔多长时间恢复当前角色的血量即可

除了战斗效果之外,Buff也可以扩展到其他场景,例如:打Boss前有个播放过场动画需求,此时是需要隐藏Boss和玩家的所有信息的,例如名字和血条.那么我们就可以做一个Buff,这个Buff扩展状态  HideHpBar,当有这个状态就隐藏就行了,还可以加上无敌状态,因为过场动画双方是不会受到伤害的

综上所述,Buff状态除了上面提到的几种高度抽象的状态外,还可以根据需求扩展各种特殊状态,满足策划的需求同时方便开发者管理逻辑





Buff修改属性(ModifyAttribute)
在游戏中Buff的添加与移除是一个频繁的过程.玩家自身的属性来源很多,如等级，装备，成就，任务，时装等等各种各样的来源.相比于Buff，这些模块修改属性的频率要远低于Buff，所以我们一般将玩家的属性划分为两层，第一层时Core（核心层），第二层是External（外部层）。Core层是玩家各个其他模块的属性总和，而External层则是Buff修改属性的总和。两者相加既为玩家的实时属性。



Buff修改运动(ModifyMotion)
在游戏中为了增加动作表现力,例如位移效果:如突进,翻滚,千斤坠,击退,击飞,拖拽,吸引等等如何实现?而且有时候会遇到各种复杂的运动打断效果,比如击飞的时候不能击退,击飞过程又能被冰冻效果定住,然后又有破冰技能击退冰冻物体并解除冰冻效果,面对这些复杂的情况如何设计?

        在我开发的系统中,运动都是统一通过MovementComponent来管理,因此就可以通过MotionModifier来与MovementComponent交互,MovementComponent中有一个CustomMotion,用来具体实现各种运动位移

        在MotionModifier中,我们会提供一个接口ApplyMotion(motionTypeId,priority,forceInterrupt)来向运动组件请求运动效果,同时设置回调UpdateBeforeMovement和UpdateAfterMovement来触发运动前和运动后的Buff效果,介绍下ApplyMotion函数的三个参数:

        montionTypeId:运动类型id,配置项.包含运动位移参数及相关数据.

        priority:运动的优先级,每个运动都有优先级,低级优先级不能打断高级优先级.

        forceInterrupt:是否忽略优先级,强制打断当前的Motion.

通过这三个参数,我们就能实现各类打断需求了.

比如说击退的运动优先级是100,击飞的运动优先级是200,那么在击飞过程中,施加击退Buff调用ApplMotion的时候就返回false,这时就可以直接销毁击退的这个Buff,即击飞时无法击退.如果击飞时被冰冻,且冻在半空中停止不动的话,那么我们就要设计一个静止Buff(如何设置???):运动优先级是300,其作用效果是速度设置为0,不受重力影响,同时修改Stun状态并挂载冰冻特效.当破冰技能消除冰冻效果时(破冰技能会造成敌人有一个击退效果),则设置破冰Buff的位移效果为击退,设置运动优先级为100,forceInterrupt为true.此时ApplyMotion强制打断运动,冰冻Buff会触发OnMotionInterrup回调,在这个接口中冰冻Buff自我销毁的同时如果有需求可以减血操作或者减缓移动Buff等等即可.

Buff修改运动仅代表修改运动的轨迹:比如一个击退只是以直线移动一段距离,而击飞是以曲线移动一段距离.同理类似于翻滚突刺都与击退是相同的运动轨迹,只是时间上有所改变,是快速到达目标点还是均速到达,这个过程中都可以设置为Stun(眩晕)状态,他们不一样的地方仅仅只是动画层的表现不同,可能策划还会设置不同的Tag和ImmuneTag标记下

最重要的一点就是,玩家在玩的时候看起来各种花里胡哨的轻功,飞行一段距离击退击飞等位移技能效果实际上就是State+Motion+Animation的组合,只要掌握这一点,就可以通过组合实现各种丰富的效果了,不要被各种花里胡哨的效果所迷惑,觉得他们都是不一样的效果,导致最后设计出来非常庞大也复杂而且特别难以维护的系统了



 Buff监听事件
Buff可以通过监听各类事件,执行特定逻辑或者修改事件数据来实现各种效果

最常见的事件监听的一般有:

OnAbilityExecuted(当技能完成时):监听某个主动技能执行成功,常用于被动技能Buff,比如说角色施法时有10%概率获得30%的攻速提升.那么我们通常是Buff-A监听OnAbilityExcuted事件,然后10%概率添加Buff-B.Buff-B的作用是修改玩家属性,增加30%攻速

OnBeforeGiveDamage,OnAfterGiveDamage(给目标造成伤害之前,之后):监听我方给目标造成伤害时触发.比如说对目标造成的伤害有10%概率无法被闪避,那么这个效果我们就可以通过监听OnBeforeGiveDamage的流程来实现,当执行伤害流程的时候,在计算这个伤害的前我们抛出一个事件Event,Event里面有当前伤害数据,Buff在调用OnBeforeGiveDamage(Event)时,修改event.Damage.DamageFlag|=DamageFlag_NotMiss,标注该伤害无法被闪避就行了,又或者如果有一个需求是给目标造成伤害后有10%几率触发DOT("Damage Over Time"（随时间造成伤害）)伤害效果,那么我们在OnAfterGiveDamage的时候取出event.Target并给这个目标加个DOT类Buff即可.

OnBeforeTakeDamage,OnAfterTakeDamage(当我方收到伤害)监听我方受到伤害时触发,如护盾类Buff通常在OnBeforeTakeDamage的时候修改伤害数据.又或者有某些Buff在受到伤害后可以触发各类效果就可以通过监听OnAfterTakeDamage事件来触发指定逻辑.

OnBeforeDead,OnAfterDead(当死亡时):监听我方死亡时触发,如果免疫致死(名刀)效果可以通过监听OnBeforeDead事件修改角色当前的Hp>0,从而让角色提前退出死亡流程来避免死亡,死亡后触发额外效果,如爆炸或者召唤其他生物都可以通过监听OnAfterDead事件来执行

OnKill(当击杀目标时)事件:监听我方击杀目标时触发,如当击杀目标后获得治疗效果即可通过监听到Kill事件时给自己加一个HOT的Buff来实现.

主要是可以通过可以扩展各类事件列表,让Buff通过监听对应事件就能执行任意逻辑,不需要与任何模块耦合,只需要抛出时间,监听事件,执行逻辑即可获得Buff功能上的扩展.

        总结: 

以上就是通过6个小结叙述了Buff系统主要模版的实现方法.通过这样的设计,可以让Buff的深度和扩展性都能够得到了极大的提升,几乎能实现各种各样的效果,足以让策划的创意得到最大限度的发挥.

为了让面试官更直观的理解,可以举以下例子供参考:

问:Buff互斥效果很常见,怎么实现?

答:前面提到的BuffTag和BuffImmuneTag(Buff免疫的类型)可以轻松实现,比如火系和水系互斥,那么无论策划的需求是有水系无法添加火系,还是存在水系的时候火系会驱散水系都可以实现,第一种情况最简单,水系Buff配置的Tag是Water的时候配置了ImmuneTag为Fire,此时存在存在水系Buff的时候就可以直接免疫火系Buff.第二种情况:配置BuffTag为Water,当OnBuffStart的时候调用驱散的接口DispelByTag(fire)就可以驱散所有火系Tag相关的Buff即可.

问:霸体效果如何实现?而且如果说存在破霸体效果又怎么实现,而且Boss的霸体效果完全不受影响又怎么实现?万一还存在特殊效果可以让Boss受到控制怎么办?

答:我们可以在策划配置BuffTag的时候根据不同的Buff设置不同的BuffTag,这个BuffTag是WeakControl(弱控制)和StrongControl(强控制).普通的霸体效果身上的Buff配置的ImmuneTag:WeakControl(弱控制)即可免疫控制效果,如果是破霸体(去取消目标身上的霸体)效果,我们就给这个BuffTag设为StrongControl就可以了,同时Boss的Buff配置ImmuneTag为WeakContorl和StrongControl(免疫若控制和强控制,这两个类型是不包含被施加的Buff去破霸体的)就可以满足免疫控制的需求了.但是如果存在一个特殊的施加Buff可以免疫霸体直接去进行控制,那么就让这个施加的Buff不要标记为WeakControl和StrongControl(意思就是他不是一个破霸体的buff,而是直接无视霸体的类型)就可以实现直接控制Boss,Boss身上的霸体无法免疫,这样写就很清晰,不需要引入任何新的系统.

问:Buff存盘那块如何处理跟施法者相关的属性数据? 比如施法者可以给目标添加一个强力的毒Buff,具体伤害是要根据施法者自身的属性决定,离线后依旧生效,直到Buff时间结束才移除.

答:Buff依然设置bNoCaster=true.但是在Buff创建的时候Context里面我们设置Context.DamageValue为根据施法者属性计算的伤害数值,然后Buff在持续造成伤害的时候直接取Context.DamageValue即可.至于说想要玩家离线在上线,Caster离线在上线后,毒的伤害数值还能实时修改的话,这样的需求是不存在的,如果说真的一定要做,当然也可以实现,只是麻烦一点也没有必要,这种需求一般也只是测试会想到,策划是不会有这样的玩法需求的;

问：常见的基于指定地点延迟触发的AOE效果怎么实现？就是类似于光辉女郎的E技能,当技能施法成功后就延迟触发，不会被打断AOE效果。（如果能被打断，我们可以用引导类技能轻松实现）


答：我们将技能标记为可指定目标地点释放，当技能Spell的时候我们先给自己加一个Buff，这个Buff仅仅用于延迟效果（当然可以有更多的可能性，如监听到某种事件立即结束并触发AOE效果），当Buff持续时间到了的时候在OnBuffDestroy的时候创建AOE效果Buff。这个AOE Buff会调用StartIntervalThink函数(这个函数是在一定时间间隔内定时执行一段代码)，在OnIntervalThink的时候通过Buff:GetAbility():GetCastPosition()为基准位置检查周围的敌方单位是否在AOE半径内，如果是，则施加作用效果。





三丶子弹系统

前言
子弹又称抛射物（Projectile），是游戏中非常常见的一个概念。它常见于各大远程职业的技能效果：通过施法创建出一个带有弹道的物体，经过飞行后命中目标并触发各类效果。在游戏中，我们经常能看见各种各样复杂多变的子弹效果，那么它们是如何实现的呢？

(未完成....)