一丶数据结构的话术:
<<字典>>:

特点:

键的唯一性：字典中的键是唯一的，不允许重复的键存在，如果尝试插入重复的键，会覆盖旧值。
动态扩展：字典可以根据需要自动扩展容量，支持动态增长。
哈希表实现：字典使用哈希表作为底层数据结构，通过哈希函数将键映射到对应的索引位置，以实现快速的查找和检索。
泛型支持：字典是泛型集合，可以指定键和值的类型，提供类型安全的操作。
优点:

快速查找：字典使用哈希表实现，通过键进行查找，具有快速的查找性能，无论字典的大小如何，查找操作的时间复杂度都接近 O(1)。
高效的插入和删除：字典提供了高效的插入和删除操作，可以根据键快速定位并修改对应的值。
键值对存储：字典以键值对的形式存储数据，可以根据键来唯一标识和访问值，适用于需要根据键进行数据关联和检索的场景.
缺点:

内存占用：字典在存储键值对时需要额外的内存空间来维护哈希表，相比于数组或列表，可能占用更多的内存。
无序性：字典中的键值对没有固定的顺序，无法保证遍历顺序与插入顺序一致。


<<集合>>:

特点:

有序集合：List 保持插入顺序，可以按照元素的顺序进行访问和遍历。
可重复元素：List 允许存储重复的元素，相同元素可以存在于集合中的不同位置。
动态扩展：List 可以根据需要自动扩展容量，支持动态增长。
优点：

动态大小：List 具有动态大小的特性，可以根据需要自动调整容量，无需手动管理数组的大小。
高效的索引访问：List 使用基于索引的访问方式，通过索引可以快速访问和修改集合中的元素，具有较高的访问效率。
方便的插入和删除操作：List 提供了插入和删除元素的方法，可以在任意位置插入或删除元素，而无需手动移动其他元素。
泛型支持：List 是泛型集合，可以指定存储的元素类型，提供了类型安全的操作.
缺点:

数据的移动：当在 List 中插入或删除元素时，可能需要移动其他元素来保持连续性，这可能会导致性能开销。
预分配内存：为了提高性能，List 在创建时会预分配一定数量的内存空间，当元素数量超过容量时，会触发重新分配内存的操作，可能导致性能下降。例如:默认容量为4,当集合数量超过4的时候,就会重新分配内存变为8,数量超过8的时候,内存就会重新分配为16,32,64,128...
<<数组>>：
特点：数组是一种线性数据结构，它由一组相同类型的元素组成，这些元素在内存中是连续存储的。
优点：数组具有快速的随机访问能力，可以通过索引直接访问任意位置的元素。
缺点：数组的大小是固定的，一旦创建后无法改变大小，需要预先知道数组的长度。插入和删除元素的操作比较低效，需要移动其他元素。


<<链表>>：
特点：链表是一种非连续的数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针。
优点：链表的大小可以动态改变，可以高效地插入和删除元素，不需要移动其他元素。
缺点：链表的随机访问能力较差，需要从头节点开始遍历才能找到指定位置的元素。


<<哈希表>>：
特点：哈希表是一种根据键（Key）直接访问值（Value）的数据结构，它通过哈希函数将键映射到存储位置。
优点：哈希表具有快速的查找和插入能力，平均情况下的时间复杂度为O(1)。
缺点：哈希表的内存消耗较大，需要维护哈希函数和处理哈希冲突的方法。

哈希表（Hash Table）是一种数据结构，用于实现关联数组或映射数据结构。它通过将键（key）映射到值（value）的方式来实现快速查找数据。在哈希表中，键经过哈希函数处理后，得到一个索引，该索引指向存储值的位置。

哈希函数（Hash Function）：哈希函数是一种将输入数据（如键）映射为固定大小值的函数。它将不同长度的输入数据映射到固定长度的输出，通常是一个哈希码（hash code）。好的哈希函数具有以下特点：

只要输入不变，输出是确定的。
对于不同的输入，输出应该尽可能不同。
哈希值的计算应该高效。
哈希碰撞（Hash Collision）：当两个不同的键通过哈希函数映射后得到相同的哈希值时，就发生了哈希碰撞。哈希碰撞可能会导致数据存储冲突，需要特殊的处理方式来解决。常见的解决哈希碰撞的方法包括开放寻址法（Open Addressing）、链地址法（Chaining）等。

哈希表通过哈希函数将键映射到索引，然后通过索引来访问存储值的位置。哈希函数的设计直接影响了哈希表的性能，一个好的哈希函数应该尽量减少哈希碰撞的概率，以提高哈希表的效率和性能。

哈希碰撞是指当两个或多个不同的输入数据（如键）经过哈希函数计算后得到相同的哈希值。哈希碰撞在使用哈希表等数据结构时是一个常见的问题，因为哈希函数通常会将不同长度的输入映射到固定长度的输出，可能会导致不同的输入映射到同一个哈希值上。

哈希碰撞的原因
哈希碰撞可能由以下原因导致：

有限的哈希空间：哈希函数的输出空间是有限的，而输入空间是无限的，这意味着不同的输入可能会映射到相同的哈希值上。

哈希函数设计不当：如果哈希函数的设计不合理，可能会导致碰撞更加频繁。

哈希碰撞的处理方式
当哈希碰撞发生时，需要采取适当的措施来解决这个问题，常见的处理方式包括：

链地址法（Chaining）：这是一种简单而有效的解决哈希碰撞的方法。在这种方法中，哈希表的每个槽位指向一个链表，具有相同哈希值的元素将被放置在同一个链表中。当发生哈希碰撞时，新元素将被插入到链表的末尾。

开放寻址法（Open Addressing）：在这种方法中，当发生哈希碰撞时，会寻找哈希表中的下一个可用位置来存储冲突的元素。这个过程可能包括线性探测、二次探测、双重哈希等策略。

再哈希（Rehashing）：当哈希碰撞频繁发生时，可以考虑重新调整哈希表的大小，并重新计算哈希函数，以减少碰撞的概率。

链表转红黑树：在一些现代编程语言和库中，当链表长度过长时，会将链表转换为更高效的数据结构，如红黑树，以提高查找效率。

完全哈希表（Perfect Hashing）：在一些特定情况下，可以使用完全哈希表来避免碰撞，这种方法通常适用于静态数据集。


<<队列>>：
特点：队列是一种先进先出（FIFO）的数据结构，只允许在队尾插入元素，在队头删除元素。
优点：队列可以高效地进行元素的插入和删除操作，适用于需要按照顺序处理数据的场景。
缺点：队列的随机访问能力较差，只能访问队头和队尾的元素。


<<栈>>：
特点：栈是一种后进先出（LIFO）的数据结构，只允许在栈顶插入和删除元素。
优点：栈可以高效地进行元素的插入和删除操作，适用于需要按照逆序处理数据的场景。
缺点：栈的随机访问能力较差，只能访问栈顶的元素。


<<总结>>：

字典是一种常用的数据结构，适用于需要根据键快速查找、插入和删除元素的场景。它具有快速的查找性能、高效的插入和删除操作，以及键值对存储的特点。但需要注意的是，字典可能占用较多的内存，并且键值对的顺序是无序的。

List 是一种常用的数据结构，适用于需要动态大小数组的情况。它具有高效的索引访问、方便的插入和删除操作，同时支持泛型和动态扩展。然而，插入和删除操作可能导致数据的移动和内存重新分配，需要在性能要求较高的场景进行评估和优化。


数组适用于需要快速随机访问元素的场景，但大小固定且插入删除操作较低效。


链表适用于需要频繁插入删除元素的场景，但随机访问能力较差。


哈希表适用于需要快速查找和插入元素的场景，但内存消耗较大。


队列适用于按照顺序处理数据的场景。


栈适用于按照逆序处理数据的场景。

二丶UI功能的具体实现
例如背包商城 根据通过服务器的数据管理派发到客户端,客户端存储到配置表中,例如MVC中的M层,然后通过C层来管理背包商城的实现逻辑的地方,管理这些数据应该向哪里派发,同时这个层也会接收数据,V层进行监听是否要刷新界面显示的逻辑,数据整理完之后就交给V层进行显示或隐藏

三丶战斗的设计,数据,框架及内部各个模块的实现细节
战斗的设计一般都是通过一下几个系统的结合实现的:
动画系统,     buff系统,     状态系统,     数值系统,
     技能系统,     并了解网络同步等

动画系统是根据Animator来实现动画的状态的,也可以创建一个动画的基类用来管理

Buff系统是最复杂的,灵活度最高,并且是最容易修改需求的地方,所以Buff一般分为三个层次 
BuffBase:所有Buff的基类,包含各类成员函数和基本接口(),
Modifier:继承于BuffBase,是一个关于buff的修改器,可以用来修改当前目标的属性状态等等
MotionModifier:继承于Modifier,代表的是此类提供修改玩家运动效果的功能.因为会牵扯到于运动组件的交互,所以抽象出一个新的类
Buff执行的流程
在Buff从创建到销毁的过程中,分为如下几个阶段:

1.Buff创建前检查当前Buff是否可创建,一般不可创建的原因就是前面提到的这个要添加的buff是否会被玩家自身带的Buff给免疫掉了,如果有免疫效果则不会创建此Buff.

2.Buff在实例化之后,生效之前(还没有加入到Buff的容器中)如果说此Buff是一个被动触发的Buff,例如Buff实例化出来的时候会抛出一个事件,等待触发,这个buff的作用是:玩家添加此Buff,这个Buff就是如果3秒钟之内别人对我施加负面Buff的话,那么会立马驱散这个负面Buff的同时在给自己添加一个护盾或者说在给自己添加一些正面的Buff效果,如果说超过这个Buff3秒还没有被负面Buff触发的话,那么就移除触发事件,这样就会意味着Buff还没有被触发就会销毁同时小心Buff的生命周期(例如LOL中轮子妈的W技能)

3.当Buff生效时(加入到Buff容器后),就提供一个抽象接口给策划配置这个Buff的具体效果

4.当Buff添加时存在相同类型且Caster(Buff施加者)相等的时候，Buff执行刷新流程（更新Buff层数，等级，持续时间等数据）。我们提供给策划一个抽象接口OnBuffRefresh，由策划配置具体效果。

5.当Buff销毁前（还未从Buff容器中移除），我们提供给策划一个抽象接口OnBuffRemove，由策划配置具体效果。

6.当Buff销毁后（已从Buff容器中移除），我们提供给策划一个抽象接口OnBuffDestroy，由策划配置具体效果。


状态系统主要是根据几个有限状态基来实现状态的切换逻辑,根据不同的状态执行不同的逻辑

数值系统是服务器里所管理分配的,同时再结合玩家自身的属性或者装备的属性来进行实时改变的

技能系统

技能系统是分为多种类型的技能,
如 被动技能,主动施法的技能,开关类的技能,激活类的技能,引导类的技能

被动类型的技能最大的特点就是在游戏开始的时候直接初始化,并且根据玩家自身属性值进行改变被动技能的数值,他需要在游戏一开始就能使用的

主动施法技能是分为前摇阶段,施法阶段,后摇阶段的最少三个生命周期的,然后通过这三个生命周期来进行该技能的逻辑处理

开关类型的技能,激活类型的技能基本上都是通过两个不同的接口来控制,一个是开,一个是关,一个是显示,一个是隐藏

引导类型的技能:就是在前摇和后摇中间这一个引导阶段,这个阶段一般分成3个接口来满足该引导式技能的需求

子弹系统:
一般分为追踪子弹,线性子弹
主要用于处理玩家释放远距离伤害,然后添加不同的特效,不同的动画来包装这个子弹的空对象实现逻辑