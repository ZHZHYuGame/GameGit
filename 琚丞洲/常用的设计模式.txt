23设计模式：
	设计模式是一套反复使用，多人知晓，经过分类编目的，代码设计经验的总结，(分类编目的意思是设计模式有很多分类，每一种设计模式有其不同作用和使用场景）（懂算法可以说算法让我们写出高效的代码），设计模式就是让我们写出优雅的代码，什么是优雅呢？就是从可扩展性，可读性，高内聚低耦合等角度去考量的。
	设计模式有设计原则：分别是单一职责原则，开放封闭原则，里氏替换原则，接口隔离原则，依赖倒置原则，迪米特法则，合成复用原则。
	（解释：单一职责——对一个类来说，只负责一个职责或者功能，不设计大而全的类，设计力度小，功能单一的类，也就是一个类只负责一项职责，一个方法只负责一个职责，提高类的可读性，可维护性，（类的职责是否越单一越好，不然，读取json文件跟写入json文件一般都在一个类中，如果分开在不同类中话，之后修改就需要修改两个脚本，如果一个忘记修改，则会报错，给自己找麻烦，也就是维护性变差了）
		       开放封闭——对扩展开放，对修改关闭，需要修改代码不修改源代码，对外封装接口和抽象，让程序有一个很好的扩展性
			里氏替换——任何基类可以出现的地方，子类一定可以出现，就是子类可以替换程序中父类对象出现的任何对象
			接口隔离——使用多个隔离接口，比使用单个接口要好，降低类之间的耦合度，强度减低依赖，降低耦合，客户端不应该强迫它依赖它不需要的接口
			依赖倒转——高层模块不应该依赖低层模块，二者都应该依赖其抽象对象，抽象不应该依赖细节，细节应该依赖抽象，依赖于抽象而不依赖于具体，依赖倒转的中心思想是面向接口编程
			迪米特法则——迪米特法则又叫"最少知道原则"，即一个类对自己依赖的类知道的越少越好，尽量只依赖必要的接口
			合成复用原则——尽量使用合成/聚合方式,而不是使用继承）
	设计模式一共有三种，分别是创建型模式，结构型模式，行为型模式。创建型模式主要在创建对象的同时隐藏了创建的逻辑，不是使用new运算符直接实列化对象，这使程序在创建对象时候更加灵活。典型的就是工厂模式，单列模式等，结构型模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式，行为型模式特别关注对象之间的通信，
	首先聊一下工厂模式，又分三种，简单工厂模式，工厂模式，抽象工厂，简单工厂模式是比较简单好理解的一种，就是用来创建不同的类型的对象，定义了一个创建对象的类，由这个类来封装实例化对象的行为，这个模式会在大量创建某种，某类或者批对象时，就会用到工厂模式，我们常用Resources.Load接口就是典型的应用了简单工厂模式，我们需要加载各种不同的资源的时候，只需要通过这个接口传递泛型参数，告知接口我们需要加载的对象的类型，然后接口内部就根据我们传入的类型和路径去创建一个这样的对象给我们，根据我们需要创建的资源类型来创建对应的实例，所以加载预制体就用到了工厂模式，使用固定语法就可以加载Resources文件夹下的资源，简单工厂模式就是根据不同的枚举类型创建不同的对象实列，简单工厂可以有效降低客户端和具体对象的耦合，将new具体任务交给了一个简单的工厂类，可以有效的进行代码复用，工厂类就是工厂模式的核心地方，可以添加各种逻辑，用于创建对应的实例，虽说简单工厂模式有违背OCP原则（开放封闭原则），但并不是说他不能用，相反其实简单工厂模式在我们日常开发种还是比较常用的。接下来是工厂模式
	工厂模式和简单工厂模式的区别就是工厂模式克服了简单工厂的违反开闭原则，将工厂模式进行抽象，将实现逻辑延迟到工厂的子类当中，工厂模式比简单工厂模式多了一层抽象，由于抽象工厂层的存在，当我们需要修改一个实现的时候，我们不需要修改工厂的角色，只需要修改实现的子类就可以完成这个工作,同样，当我们需要增加一个新产品的时候，我们也不需要修改工厂的角色，只需要增加一个新的实现工厂来完成实现就可以了，符合开闭原则，这样更适合扩展，并且的话整体代码的层级结构更加分明，创建实际产品的职责更加单一，还有一个抽象工厂模式，
	抽象工厂模式跟他们区别在于抽象工厂模式在工厂模式的基础上增加了产品族的概念，意思是说抽象工厂用来生成一系列产品时是更好的，一个工厂可以生产一系列的产品，这些产品的定义都在工厂当中。抽象工厂模式可以将简单工厂模式和工厂模式进行整合，从设计层面看，抽象工厂模式就是简单工厂模式的改进（或者进一步抽象），将工厂模式抽象成两层，抽象工厂和具体实现工厂的子类，当我们还需要增加一个产生系列的时候，我们只需要增加一个工厂，实现其中所有产品的实现就行了，很轻松的增加了一系列产品的实现，从简单工厂到工厂再到抽象工厂模式，可以看到抽象的程度越来越高，能解决的问题也越来越复杂，不过，抽象工厂模式并不是一个很灵活的解决方案，（（知道还有什么方案可以讲）而且，对于u3d中组件的创建，（事实上是有一些非常灵活的解决方案可以处理，实体于组件系统，相当适合于组件的构建，比起工厂方法来说更加灵活和易于扩展）工厂模式就是将实列化对象的代码提取出来，放到一个工厂类中统一管理和维护，做到和主项目的依赖关系的解耦，从而提高项目的扩展和维护性。接下来讲讲策略模式
	策略模式应用的环境也很多，就是当大数据系统把文件给推送过来，根据不同的类型采取不同的解析方式的时候，正常可以用if语句进行个判断，不同条件执行不同的逻辑，但这样写的代码有问题，如果分支变多，这里的代码会变的臃肿，难以维护，可读性低，如果你需要接入一种新的解析类型，那只能再原有代码上修改，就是违背了面向对象编程的开放封闭原则以及单一职责原则，如果代码是这个样子，有多个if。。。else等条件分支，并且每个条件分支，可以封装起来替换的话，我们就可以用策略模式，
	策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户，emm，就是策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式怎么用呢？一个接口或者抽象类，里面两个方法（一个方法匹配类型，一个可替换的逻辑实现方法），不同策略的差异化实现（就是不同策略的实现类），我们借助spring的生命周期，使用ApplicationContextAware接口，把对用的策略，初始化到map里面，然后对外提供resolveFile方法。
	责任链模式会用到的场景是，进行一个任务派发之前需要一些什么非空校验，安全校验，黑名单校验，规则拦截等等的时候，有时候就会用异常来实现，当用异常来实现的时候，就是用异常来做逻辑条件判断，如果后续越来越复杂的话，会出现一些问题，如异常只能返回异常信息，不能返回更多的字段，这时候就会需要自定义异常类，并且，有规定还禁止用异常做逻辑判断，（【强制】异常不要用来做流程控制，条件控制，说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多）。
	当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式，责任链模式为请求创建了一个接收者对象的链，执行链上有多个对象节点，每个对象节点都有机会（条件匹配）处理请求事务，如果某个对象节点处理完了，就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕，这种模式给予请求的类型，对请求的发送者和接收者进行解耦。责任链模式实际上是一种处理请求的模式，它让多个处理器（对象节点）都有机会处理该请求，直到其中某个处理成功为止，责任链模式把多个处理器串成链，然后让请求在链上传递；责任链模式也是申明一个接口或者抽象类，每个对象差异化处理（将每个对象进行不同的实现），对象链（数组）初始化（连起来）这个接口或者抽象类中有一个指向责任下一个对象的属性，一个设置下一个对象的set方法，给子类对象差异化实现的方法，在责任链上每个对象的差异化处理，就是开头说的那种情况，需要参数校验对象，安全校验对象，黑名单校验对象等等，
	模板方法模式使用的业务场景如假设内部系统不同商户，调用我们系统接口，去跟外部第三方系统交互（http方式）一个请求都会经历这几个流程，（查询商户信息，对请求报文加签，发送http请求出去，对返回的报文验签），不同商户走代理出去的，也有的是走直连（了解一下代理和直连都是什么情况），如果有A，B商户接入，进行了逻辑的实现，现在如果有个C商户接入，则现在需要再实现一套这样的代码，然后这样的代码就会重复，一些通用的方法，却在每一个子类都重新写了这个方法，优化办法就是用模板方法模式，首先定义一个操作中的算法骨架流程，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤，它的核心思想就是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，这样不同的子类就可以定义出不同的步骤。一个抽象类，定义骨架流程（抽象方法放一起），确定的共同方法步骤，放到抽象类（去除抽象方法标记）不确定的步骤，给子类去差异化实现（因为是否走代理流程是不确定的，所以给子类去实现）。
	观察者模式的用户场景就是当玩家注册成功后要求再给玩家发个消息或者邮件，按照正常的写法就是调用一个方法进行一个调用通知玩家，那如果又加需求，现在注册成功的用户再给用户发一条短信通知，于是还得改之前的代码，然后就违背开放封闭原则，并且，如果调发短信的接口失败了，是不是又影响到用户的注册，这时候，就会需要一个异步方法给通知消息就好，就可以用观察者模式，观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都得到通知并被完成业务的更新。观察者模式属于行为模式，一个对象（被观察者）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知，它的主要成员就是观察者和被观察者，被观察者：目标对象，状态发生变化时，将通知所有的观察者。观察者：接受被观察者的状态变化通知，执行预先定义的业务。使用环境是完成某件事情后，异步通知场景，例如：登录成功，发个IM消息等等。一个观察者模式实现还是简单的，一个被观察者者的类Observerable，多个观察者Observer，观察者的差异化实现，经典观察者模式封装,
	单列模式也是常用的一个设计模式，在一些框架中就会经常见到，单例模式是保证一个类只有一个实例，并且只提供一个全局访问点，那么这个类就是单例类，这个设计模式叫做单例设计模式，单例模式常用于管理全局数据，游戏状态或者资源管理，通过单例模式。我们可以在整个应该程序中方便地访问特定对象，重量级对象，不需要多个实例，在业务概念上，如果有一些数据在系统中只应该保存一份，那么这些情况就适合单例模式，比如就是游戏中数据配置表，唯一id号码生成器等等。
	单例模式有方式，一种懒汉模式（无锁）延迟加载，只有在真正使用的时候，才开始实列化，这种首先有线程安全问题，需要加锁，限制用到环境，只能单线程下使用，如果多线程下，一个线程还没进入逻辑，另外一个线程也进行了访问，就会产生多个实例，在实际开发中，不要用这种方式，如果不用多线程，这种方式还是可以用的，接下来是单锁，单锁解决了线程不安全的问题，但又出现了新的问题，效率太低，每个线程想访问的时候都需要执行一次同步，如果第一个线程加锁，第二个线程只能等待，效率低下，这种方式开发中不太推荐，下面就是双锁，既解决了懒汉加载问题，又解决了线程同步的效率问题，这种方式就是开发中经常用到的方式，二是饿汉模式，类加载的初始化阶段就完成实例的初始化，本质上就是借助jvm类的加载机制，保证实例的唯一性，写法简单，在类装的时候就实现 了实例化，避免了线程同步问题，但这种单例模式可用，可能造成内存的浪费，单列模式也有几个小缺点，继承单例的类不适合继承，多态特性也不友好，也不是完全不支持，理论上，单例类也可以被继承，也可以实现多态，只是实现起来会非常奇怪，导致代码可读性变差，所以，选择设计成单例，就意味着放弃了继承和多态这两个强有力的面向对象特性，下一个缺点就是看代码时都希望一眼看出类鱼类之间的依赖关系，搞清楚这个类依赖了那些外部类，设计成单例后，不需要显示创建，所以导致我们需要仔细查看每个函数，就是看代码比较复杂，第三个就设计成单例之后代表这个类只能有一次实例，如果未来这个类需要有两个或多个实例，那我们需要对代码有比较大的一个改动，例如，设计初期，我们可能觉的系统中应该有一个数据库连接池，这样可以方便我们控制数据库连接资源的消耗，所以就设计成单例，但之后发现，我们可能会用到好几种数据库，不同的数据库访问的接口都不一样，这样就需要不同的连接池对象，也就不能设计成单例类，虽说单例模式有缺点，但也是常用的设计模式之一，需要全局访问点的情况就需要单例模式，可以轻松将其应用到不同的管理类或者全局性的对象中，提高代码的可维护性和灵活性，可以根据具体需求对单例模式进行一个扩展和优化。




	